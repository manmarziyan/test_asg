<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <style>
  html, body {
      width: 100%;
      height: 100%;
      margin: 0px;
      border: 0;
      overflow: hidden; /*  Disable scrollbars */
      display: block;  /* No floating content on sides */
    }
  </style>
  <script type="application/javascript">

if(window.addEventListener) {
    window.addEventListener('load', function () {
    var canvas, context, tool, c_x, c_y;
    var line_state = []; //Store all drawing history
    var color = 'red'; // Default color
    var penUP = false; // Track Pen UP/DOWN
    var touchOn = false; // Track Touch Start/End movement

    function init () {
        canvas = document.getElementById('canvas');
        if (!canvas) {
            alert('Error: I cannot find the canvas element!');
            return;
        }

        if (!canvas.getContext) {
            alert('Error: no canvas.getContext!');
            return;
        }

        // resize canvas to 80% of window width and height 
        init_canvas_size();

        context = canvas.getContext('2d');
        if (!context) {
            alert('Error: failed to getContext!');
            return;
        }

        // Default color and mouse 
        context.strokeStyle = color;
        context.strokeRect(0, 0, 30, 30);

        // Create a new pen
        tool = new pen();

        // All the event listeners.
        canvas.addEventListener('mousedown', ev_canvas, false);
        canvas.addEventListener('mousemove', ev_canvas, false);
        canvas.addEventListener('mouseup',   ev_canvas, false);
        canvas.addEventListener('keypress', ev_canvas, true);
        canvas.addEventListener('keydown', ev_canvas, true);
        canvas.addEventListener('touchmove', ev_canvas, true);
        canvas.addEventListener('touchstart', ev_canvas, true); 
        canvas.addEventListener('touchend', ev_canvas, true); 
   
        // requires special handling due to unreliable innerHeight when mobile orientation changes. 
        window.addEventListener('orientationchange', function () {
            orientationChanged().then(function() {
              reinit_resize_canvas();
            });
        });
    }

    /*  To check if this needs to be done. 
    window.addEventListener('resize', function(){
        init_canvas_size();
    }, false);
    */
    // Wait for 120 frames to see if height has stabilized. 
   function orientationChanged() {
        const timeout = 120;
        return new window.Promise(function(resolve) {
        const go = (i, height0) => {
            window.innerHeight != height0 || i >= timeout ?
            resolve() :
            window.requestAnimationFrame(() => go(i + 1, height0));
        };
        go(0, window.innerHeight);
        });
    }

    function init_canvas_size() {
        canvas.width  = Math.round(window.innerWidth  * 80 / 100);  
        canvas.height = Math.round(window.innerHeight * 80 / 100);
    }

    function pen() {
        var tool = this;
        this.started = false;

        this.mousedown = function (ev) {
           context.beginPath();
           context.moveTo(ev._x, ev._y);           
        };

        this.mousemove = function (ev) {
            if(!penUP) {
                context.lineTo(ev._x, ev._y);
                context.stroke();
                line_state.push({x:ev._x, y:ev._y, c:color, t:'lineTo'});
                drawpen(ev);
            } else {
                line_state.push({x:ev._x, y:ev._y, c:color, t:'moveTo'});
                context.moveTo(ev._x, ev._y);
                drawpen(ev);
                c_x = ev._x; 
                c_y = ev._y;
            }
        };

        // Do nothing for now
        this.mouseup = function (ev) {
        };

        this.touchstart = function (ev) {
            touchOn = true;
            context.beginPath();
            context.moveTo(ev.touches[0].clientX, ev.touches[0].clientY);  
            line_state.push({x:ev.touches[0].clientX, y:ev.touches[0].clientY, c:color, t:'moveTo'});
         };
 
        this.touchmove = function (ev) {
            var x = ev.touches[0].clientX;
            var y = ev.touches[0].clientY;
            var xy = {_x: x, _y: y};
            if(touchOn) {
                context.lineTo(x, y);
                context.stroke();
                line_state.push({x:x, y:y, c:color, t:'lineTo'});
                drawpen(xy);
            } 
        };

        this.touchend = function (ev) {
            touchOn = false;
         };

        function drawpen(ev) {
            var x = ev._x - 15;
            var y = ev._y - 15;
            context.clearRect(0, 0, canvas.width, canvas.height);
            redraw();
            context.strokeRect(x, y, 30, 30);
        }

        function changeColor(color) {
            context.beginPath();
            context.strokeStyle = color;
        }

        function redraw() {
            changeColor(color);
            var prev_color = color;
            line_state.forEach(function(draw_item){
                if(draw_item.t == 'lineTo') {
                    if(draw_item.c !== prev_color) {
                        context.stroke();
                        changeColor(draw_item.c);
                        prev_color = draw_item.c;
                    }
                    context.lineTo(draw_item.x, draw_item.y);
                } else {
                    context.moveTo(draw_item.x, draw_item.y);
                }
            });
            context.stroke();
        }

        this.keypress = function(ev) {
            context.beginPath();
            if(ev.keyCode == 98) {
                color = context.strokeStyle = 'blue';
            } else if(ev.keyCode == 103) {
                color = context.strokeStyle = 'green';
            } else if(ev.keyCode == 114) {
                color = context.strokeStyle = 'red';
            } else if(ev.keyCode == 121) {
                color = context.strokeStyle = 'yellow';
            } else if(ev.keyCode == 32) { 
                // Space button -> Clear canvas
                clear_canvas();
            }   else {
                console.log('KP: ' + ev.keyCode);
            }
        }

        // Handle Arrow Keys 
        this.keydown = function(ev) {
            // UP: 38, Down: 40
            if(ev.keyCode == 38) {
                penUP = true;
                context.beginPath();
            } else if(ev.keyCode == 40) {
                context.beginPath();
                context.moveTo(c_x, c_y);
                penUP = false;
            }
        }
    }

    function clear_canvas() {
        context.clearRect(0,0, canvas.width, canvas.height);
        line_state = []
        color = 'red';
        context.strokeStyle = 'red';
    }
    function reinit_resize_canvas() {
        clear_canvas();
        init_canvas_size();
    }

    function ev_canvas (ev) {
        if (ev.layerX || ev.layerX == 0) { // Firefox
            ev._x = ev.layerX;
            ev._y = ev.layerY;
        } else if (ev.offsetX || ev.offsetX == 0) { // Opera
            ev._x = ev.offsetX;
            ev._y = ev.offsetY;
        }
        // Call the event handler of the pen
        var func = tool[ev.type];
        if (func) {
        func(ev);
        }
    }
    
    init();
}, false); }
</script>
 </head>
 <body>
   <canvas id="canvas" width="150" height="150" tabindex="1"></canvas>
 </body>
</html>
